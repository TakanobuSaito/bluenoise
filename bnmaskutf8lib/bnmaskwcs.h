////////////////////////
// blue noiseマスク生成
// bnmask.h
#pragma once

// only for debug(save/load as bmp file)
#include <windows.h>
// only for debug(save/load as bmp file)


#ifdef DLLDEF
#    undef DLLDEF
#endif

#ifdef BNMASKUTF8LIB_EXPORTS
#    define DLLDEF __declspec(dllexport)
#else
#ifdef BNMASKUTF8LIB_IMPORTS
#    define DLLDEF __declspec(dllimport)
#else
#    define DLLDEF 
#endif // BNMASK_IMPORTS
#endif // BNMASK_EXPORTS
#pragma pack(8)


// Ratio of bit1/(bit0 + bit1) generated by white noise(ホワイトノイズのbit1の比率)
// (This value is from Robert Ulichney,"The void-and-cluster method for dither array generation"(論文では1.0/9.0程度)
#define WHITETHRESHOLD  1.0/9.0
// Parameters of Gauss filter(low pass filter)(ガウスフィルタ(ローパスフィルタ))
#define GAUSSSIGMA		1.5			// σ
#define GAUSSWINDOWSIZE	5			// 窓サイズ/2 + 1
////////////////////////////////
// cluster      :The pixel which has max value(after low pass filter)
// void         :The pixel which has min value(after low pass filter)
// basic action :Move bit1 from "cluster" to "void".
// algorithms   :Repeat "basic action" until no pixel to move is exist.
// ----------------------------------------------------------------------------
// ローパスフィルタをかけて最も値の大きい部分がcluster
// 最も値が小さい部分がvoid
// clusterからvoidへホワイトノイズマスクのbit1を移すことによって、ローパスフィルタ後の
// 平滑化が均質となる(低周波成分が小さくなり高周波成分だけ残る。すなわちブルーノイズとなる)
////////////////////////////////
// Original             :"void and cluster" method: use cyclic convolution by fft/inverse fft
// Ultra Fast algorithms:use spatial processing(space filter) 
// 
// ローパスフィルタは、循環畳み込み(cyclic convolution)を行なう
// ブルーノイズの論文の一部では、fftと逆fftを使った高速計算法によって、循環畳み込みを計算しているが
// 面倒くさいので、周波数変換せずに空間処理だけで循環畳み込みを計算している(fft/逆fftを使わない)。
//////////////////
// Original             :recalculate cyclic convolution after "basic action"
// Ultra Fast algorithms:recalculate near moved pixels(cluster pixel and void pixel)  
//                      :Make indexes for all pixels. Search void and cluster pixel by indexes.(Olog2N : N is number of pixel)
// Disadvantages        :"Ultra Fast algorithms" uses many memory. It used (24 * number of pixels(16 * number of pixels for 32bit library)) bytes for indexes.
// -----------------------------------------------------------------------------
// 原論文ではclusterからvoidに１ドット移すたびに、循環畳み込みを再計算するとあるが、計算量が爆発して
// しまう。このライブラリでは、上記の空間処理と同じ計算法で差分だけ計算することで
//「超高速void and cluster法を実現」

////////////////////////
// Blue Noise Mask class
typedef struct _stPoint {
	int		x;
	int		y;
	double	d;
} stPoint;
class DLLDEF CBNMask {
public:
	CBNMask();
	~CBNMask();
public:
	///////////////////
	// make blue noise matrix for sigle plane
	// シングルプレーン
	// ブルーノイズマトリクスを作成する
	// 入力
	//	int		width;		mask width(pixel)(マスク幅(単位ピクセル))
	//	int		height;		mask height(pixel)マスク高さ(単位ピクセル)
	//  int     level;      number of gradation(元画像の階調数)
	//  int     ws;         window size of gauss filter, default value is 7.(ガウスフィルタウィンドウサイズ(デフォルト値7(7x7のウィンドウ)))
	//  double  sigma;      standard deviation of gauss filter, default value is 1.5.(ガウスフィルタの標準偏差(デフォルト値1.5))
	// return valune(戻り値)
	//  0...........OK(正常終了)
	//	minus(負)...error(エラー) ref.errcode.h
	int				makebluenoisematrix(int width,int height,int level = 256,int ws = GAUSSWINDOWSIZE * 2 - 1,double sigma = GAUSSSIGMA);
	// 外部に保存してあるmatrixrawを設定
	int				msetbluenoisematrixraw(int width,int height,unsigned int pmatrixraw[256][256]);
	///////////////////
	// make multi plane blue noise matrix
	// シングルプレーンのブルーノイズマトリクスを元にしてマルチプレーンのブルーノイズマトリクスを作る
	// シングルプレーンと同じパラメータを使う
	// 分割するには、ブルーノイズマトリクスが十分な大きさを持つことが必要(64×64以上が望ましい)
	// 処理時間は、makebluenoisematrix()×プレーン数と同等
	// 入力
	//  int      componentnum;     number of planes(RGB...3/CMYK...4/max.8)(プレーン数(RGBなら3、CMYKなら4。最大8まで可能)
	//                             プレーン数が多い場合は128×128や256×256で実行する方が品質が向上する)
	// return valune(戻り値)
	//  0...........OK(正常終了)
	//	minus(負)...error(エラー) ref.errcode.h
	virtual int		mseparatebluenoisematrix(int componentnum);
	// this function is abandoned.
	// 2009/05/22、ムラ改善テスト版
	// 結局効果なし　不使用
	int				mseparatebluenoisematrixjoyo(int componentnum);
public:
	// accessor(アクセサ)
	int				mgetwidth() {return mwidth;}
	int				mgetheight() {return mheight;}
	// int no...component no.(plane no.)
	// return value
	//  blue noise mask(mwidth * mheight)
	//  this function is prepared for debug. You can not use return value for ordered dither.(ref.next function/mgetpmatrix)
	unsigned char*	mgetpmask(int no = 0)
	{
		if(mcomponentnum == 1)
			return mpmask;
		else
			return mppchild[no]->mgetpmask(0);
	}	// mwidth×mheightのマスクを返す
												// ordered dither時には不要、デバッグ・テスト用のアクセサ
	// int no...component no.(plane no.)
	// return value
	//  blue noise matrix(mwidth * mheight)
	//  You can use return value for ordered dither.(ref.next function/mgetpmatrix)
	unsigned int*	mgetpmatrix(int no = 0) {
		if(mcomponentnum == 1)
			return mpmatrix;
		else
			return mppchild[no]->mgetpmatrix(0);
	}		// ordered dither用のマトリクスを返す
	unsigned int*	mgetpmatrixraw(int no = 0) {
		if(mcomponentnum == 1)
			return mpmatrixraw;
		else
			return mppchild[no]->mgetpmatrixraw(0);
	}		// ordered dither用のマトリクスを返す
//////////////////////////////
// From this line on, there are functions for debug.
// 1....ordered dither function to make ordered dither image from grayscale image or multiplane color image(number of plane is from 1 to 8).
// 2....log functions (sometimes output bmp image)
// 3....save/load library status on the way
// ------------------------------------------------------------------------
// 以下はデバッグ用の関数
// 1....実際に、２値、多値oedered ditherをする関数
// 2....途中経過を画像化してbmpファイル出力する関数
// 3....途中経過のデータをsave/loadする関数(256×256だと収束に数十分かかるので、収束結果後のテスト・デバッグを支援)
public:

	// 1...組織的ディザユーティリティ
	// 生成したマトリクスを使ってordered ditherを実行する
	//     (通常は、アプリケーション側でマトリクスを取得して、diteringを実行する)
	// 入力
	// 画像は、１プレーン分の画像(256階調画像専用)
	//  int             no;             使用するプレーン番号(0〜プレーン数-1)を指定
	//                                  同じプレーン番号を指定するとdot-on-dotのブルーノイズマトリクス処理となる
	//	int				width;			画像の幅(単位ピクセル)
	//	int				height;			画像の高さ(単位ピクセル)
	//	int				scanlinesize1;	画像の１ラインのバイト数
	//	unsigned char*	pdata1;			256階調画像
	//	int				scanlinesize2;	出力2/4階調画像の１ラインのバイト数
	// 出力
	//  unsigned char*	pdata2;			２階調画像
	void			mordereddither2(int no,int width,int height,int scanlinesize1,unsigned char* pdata1,
							int scanlinesize2,unsigned char* pdata2);
	void			mordereddither4(int no,int width,int height,int scanlinesize1,unsigned char* pdata1,
							int scanlinesize2,unsigned char* pdata2);
	// 比較用 white noiseによるディザリング
	void			mordereddither2white(int no,int width,int height,int scanlinesize1,unsigned char* pdata1,
							int scanlinesize2,unsigned char* pdata2);
	void			mordereddither4white(int no,int width,int height,int scanlinesize1,unsigned char* pdata1,
							int scanlinesize2,unsigned char* pdata2);
	// 2...組織的ディザユーティリティ
	//     1行単位で処理するバージョン
	// 入力
	//   int            y;               行番号
	void			morderedditherline2(int no,int width,int y,unsigned char* pdata1,unsigned char* pdata2);
	void			morderedditherline4(int no,int width,int y,unsigned char* pdata1,unsigned char* pdata2);
// マトリクス以外のワーク領域を全て解放する
// 単体テスト時にメモリの圧迫をなくすため(キャッシュを効きやすくする)
	virtual void	mclearwork();
// 途中経過save/load
public:
	// 入力
	//  wchar_t*           filename;        セーブ／ロードファイル名
	// return valune(戻り値)
	//  0...........OK(正常終了)
	//	minus(負)...error(エラー) ref.errcode.h
	int					msavebnm(wchar_t* filename);
	int					mloadbnm(wchar_t* filename);
// 最終成果物save/load
public:
	// 入力
	//  wchar_t*           filename;        セーブ／ロードファイル名
	// return valune(戻り値)
	//  0...........OK(正常終了)
	//	minus(負)...error(エラー) ref.errcode.h
	int					msavebnmatrixraw(wchar_t* filename);
	int					mloadbnmatrixraw(wchar_t* filename);
private:
	int					msavebnmatrixraw(FILE* fp);
	int					mloadbnmatrixraw(FILE* fp);
public:
	// ブルーノイズをnum刻みで、擬似グレイスケール画像として出力する
	int					msavematrixrawasbmp(wchar_t* filename, int num);
	// ホワイトノイズをnum刻みで、擬似グレイスケール画像として出力する
	int					msavewhitenoiseasbmp(wchar_t* filename, int num);
public:
	// Dithering by error diffusion method. (Floyd & Steinberg)
	// For evaluation of Quality and speed.
	// 品質、速度比較用の誤差拡散プログラム
	// Floyd & Steinberg方式
	// 入力
	// 画像は、１プレーン分の画像(256階調画像専用)
	// RGBの場合、各プレーンに対して処理を３回行なう
	//	int				width;			画像の幅(単位ピクセル)
	//	int				height;			画像の高さ(単位ピクセル)
	//	int				scanlinesize1;	画像の１ラインのバイト数
	//	unsigned char*	pdata1;			256階調画像
	//	float*			pdata2;         計算用のワークエリア sizeof(float) * width * heightバイト必要
	// 出力
	//  unsigned char*	pdata3;			2/4階調画像
	void			mfloydsteinberg2(int width,int height,int scanlinesize1,unsigned char* pdata1,float* pdata2,unsigned char* pdata3);
	void			mfloydsteinberg4(int width,int height,int scanlinesize1,unsigned char* pdata1,float* pdata2,unsigned char* pdata3);
protected:
	int				mcomponentnum;		// プレーン数(デフォルト値1)
	CBNMask**		mppchild;			// マルチプレーンインスタンス(mcomponentnum - 1個)
	void			mclearchild();
	void			mclearchildwork();
	int				mpixelnum;			// 1の数
	int				mwidth;				// マスク幅
	int				mheight;			// マスク高さ
	unsigned char*	mpmask;				// Blue Noise Mask
	unsigned char*	mpmask_phase1;		// phase1のワーク(mpmaskのコピーから開始)
	unsigned char*	mpmask_phase23;		// phase2/phase3のワーク(mpmaskのコピーから開始)
	unsigned char*	mpmaskinc;			// (mgausstablesize * 2 - 1) * (mgausstablesize * 2 - 1)のインクリメントマスク
	double*			mpgauss1;			// ガウスフィルタ×(ホワイト→ブルー)ノイズマスク(1に対応)
	double*			mpgausswk;			// ガウスフィルタ計算ワーク
	double*			mpgauss1_phase1;	// phase1のワーク
	double*			mpgauss0;			// ガウスフィルタ×(ホワイト→ブルー)ノイズマスク(0に対応)
	double*			mpgauss0_phase23;	// phase2/phase3のワーク
	double*			mpgaussinc;			// (mgausstablesize * 2 - 1) * (mgausstablesize * 2 - 1)のインクリメント表
	double*			mpgaussincwk;		// mpgaussinc0ワーク
	stPoint*		mpgaussptr;			// ガウスフィルタの各座標
	unsigned int*	mpmatrixraw;		// Blue Noise Matrix(階調数で正規化前)
	unsigned int*	mpmatrix;			// Blue Noise Matrix
	void			mclearbluenoisemask();
	void			mcleargauss();
	virtual int		mcalcmaxgauss(int revflag,int deleteonly,int width,int height,unsigned char* pmask,double* pgauss,int& x,int& y,struct _iobuf* fp = NULL);
	virtual void	mincdecgauss(int incflag,int zeroone,int width,int height,unsigned char* pmask,double* pgauss,int x,int y);
	void			mclearbluenoisematrix();
	// 部分ソート
	void			mpartialsort(int width,int height,stPoint* ptr);
	void			mpartialsortrow1(int width,stPoint* ptr);
	void			mpartialsortrow2(int width,stPoint* ptr,double dmax);
	// mpmatrixだけ残す
	void			mclearbluenoisematrix2();
// ガウスフィルタ
protected:
	double			msigma;					// σ原論文では1.5位がベストらしい
	int				mgausstablesize;		// ガウス窓サイズ：原論文では7(便宜のため必ず奇数)
	int				mlevel;					// 元画像の１プレーンの階調数
	int				mversion;				// 元画像の１プレーンの階調数
	double*			mpweighttable;			// 窓サイズ/2 + 1のテーブルサイズ
	void			mclearweighttable();
	int				mcalculateweighttable();	// 
	void			mgauss2passx(int width,int height,double* pgaussy,double* pgauss);
	//  int		flag;		1...*ps1が1の場合
	//                      0...*ps1が0の場合
	void			mgauss2passy(int width,int height,unsigned char* pmask,int flag,double* pgauss);
protected:
	// mpmask上にホワイトマスクを生成
	int				makewhitenoisemask(double threshold);
	// void-and-cluster法でホワイトノイズマスクをブルーノイズマスクに変換
	virtual int		minitvoidandcluster();
	int				mvoidandcluster();
	// mpmatrixrawがあって、正規化mpmatrixが無い場合には作る(一瞬)
	int				mconvertmatrixraw();
	// ブルーノイズマスクをブルーノイズ行列に変換(ordered dither法のマトリクスに相当)
	int				mask2matrix();
	int				mask2matrix1();		// 原論文フェーズ1
	int				mask2matrix23();	// 原論文フェーズ2/3
	virtual int		minitmask2matrix();		// 原論文フェーズ1/2/3
public:
	// マルチプレーン対応
	int				msetbluenoisemask(unsigned int* pmatrixraw,int low,int high,int width,int height,int level,int ws,double sigma);
	// 2009/05/22改善トライアル
	int				msetbluenoisemaskjoyo(unsigned int* pmatrixraw,int joyo,int width,int height,int level,int ws,double sigma);
// bmpファイル出力
protected:
	BITMAPFILEHEADER*	mpbfh;
    BITMAPINFOHEADER*	mpbih;
    RGBQUAD*			mprgb;
    FILE*               mfp;
	void				mclearbmp();
	// bmpファイル保存
	int					msavebmp(wchar_t* filename,int width,int height,int depth,int scanlinesize,int photometric,int dpi,unsigned char* pdata);
	int					makebmpheader(int width,int height,int depth,int scanlinesize,int photometric,int dpi);
protected:
	int					msavebnm(FILE* fp);
	int					mloadbnm(FILE* fp);
	int					mloadbnm2(FILE* fp);
// 以下は単体テスト用
// テスト後も残しておく
public:
	// mpmatrixrawのRAW出力
	int					msavematrixraw(wchar_t* filename);
	// "1"/"0"ピクセルのカウント
	int					mcountpixel(int zeroone,unsigned char* pdata);
	void				mconvolutiontest();
	// 比較用のマトリクスのロード
	void				mloadpreparedmatrix(int size,wchar_t* filename);
};
/////////////////////////
// マトリクス作成高速化版
// 0....最大値参照、最小値参照、削除、追加を高速で実行するため、平衡木構造を採用する
// 1....画像の(x,y)に対応したノードインスタンス配列を作成する
// 2....マスクの１に対応する木と０に対応する木を作成する
// 3....最大値参照は１に対応する「１木」の最大値と同順位のノードポインタ配列
// 4....最大値削除は、「１木」からノードをはずし、「０木」にノードを挿入
// 5....最大値周辺値更新は、「１木」「０木」を対象に削除＋挿入を繰り返す
// 6....最小値参照は０に対応する「０木」の最大値と同順位のノードポインタ配列
// 7....最小値削除は、「０木」からノードをはずし、「１木」にノードを挿入
// 8....最小値周辺値更新は、「０木」「１木」を対象に削除＋挿入を繰り返す
//     インスタンス配列            １に対応する平衡木リンク      ０に対応する平衡木リンク
// +-----+-----+-----+-----+             +-----+                        +-----+
// |     |     |     |     |             |     |                        |     |
// +--+--+--+--+--+--+--+--+             +--+--+                        +--+--+
// |・|・|・|・|・|・|・|・|             |・|・|                        |・|・|
// +--+--+--+--+--+--+--+--+             ++-+-++                        ++-+-++
// |     |     |     |     |　　  　　　　|   |　                      　|   |　
// +--+--+--+--+--+--+--+--+          +---+   +---+                  +---+   +---+
// |・|・|・|・|・|・|・|・|          |           |                  |           |
// +--+--+--+--+--+--+--+--+       +--+--+     +--+--+            +--+--+     +--+--+
// |     |     |     |     |       |     |     |     |            |     |     |     |  
// +--+--+--+--+--+--+--+--+       +--+--+     +--+--+            +--+--+     +--+--+
// |・|・|・|・|・|・|・|・|       |・|・|     |・|・|            |・|・|     |・|・|
// +--+--+--+--+--+--+--+--+       +--+--+     +--+--+            +--+--+     +--+--+
// 平衡木としては、単純二分木、treapを候補とする。もともとホワイトノイズからブルーノイズに
// 更新されるデータ列を入力するため単純二分木でも木の平衡性がある程度保たれると思われる。
// 平衡性に問題がある場合は、比較的データ構造が単純な平衡木であるtreapも試す。
// AVL木、赤黒木はノードのサイズが大きく64bitでもきつくなるため論外
// 1...ノード(32bitでは16bytes/64bitでは24bytes、treap版でそれぞれ+4bytes)
//           (4k×4kでは16Mノードで32bitで256Mbytes/treap版で320Mbytes)
//           (8k×8kでは64Mノードで64bitで1.5Gbytes/treap版で1.8Gbytes)
//           (16k×16kでは256Mノードで64bitで6GBytes/treap版で7.5Gbytes)　32Gbytesメモリでの限界
//           (32k×32kでは1Gノードで64bitで24GBytes/treap版で30Gbytes)　  他の領域も考えると64Gbytesメモリが必要
typedef struct _stBNode {
	double				d;          // ノード値(インスタンスアドレスから計算可能だが、参照回数が多いので)
//	int					x,y;        // 対応画素座標(インスタンスアドレスから計算可能で、参照回数が少ない)
//	double				valance;	// treapバランス調整用
	struct _stBNode*    pleft;
	struct _stBNode*    pright;
} stBNode;
#define MAX_SAMENUM		4096
class DLLDEF CBNMaskFast : public CBNMask {
public:
	CBNMaskFast();
	~CBNMaskFast();
private:
	stBNode*			mproot1;					// 「１木」のルートノード
	stBNode*			mproot0;					// 「２木」のルートノード
	stBNode*			mpnode;						// ノードインスタンス領域
	int					msamenum;					// 同順位個数
	int					maxsamenum;
	stBNode*			mptraverse[MAX_SAMENUM];	// 同順位バッファ
	void				mclearnode();
	// 二分木作成(treap作成)
	virtual int			maketree(unsigned char* pmask,double* pdata1,double* pdata0);
// 木の操作用
private:
	// 同順位のデータを巡回収集
	int					mtraversemaxdata(stBNode* proot);
	// ノード挿入
	void				minsertnode(stBNode** proot,stBNode* pnode);
	// ノード削除
	int					mdeletenode(stBNode** proot,stBNode* pnode);
	// 深さを返す
	int					mgettreedepth(stBNode* proot);
	void				moverlayrand(double* pgauss1,double* pgauss0);
// デバッグ専用
private:
	// ループノードのチェック
	int					mcheckloopnode();
// 仮想関数
protected:
	virtual int			minitmask2matrix();		// 原論文フェーズ1,2,3
	virtual int			minitvoidandcluster();
	virtual int			mcalcmaxgauss(int revflag,int deleteonly,int width,int height,unsigned char* pmask,double* pgauss,int& x,int& y,struct _iobuf* fp = NULL);
	virtual void		mincdecgauss(int incflag,int zeroone,int width,int height,unsigned char* pmask,double* pgauss,int x,int y);
public:
	virtual void		mclearwork();
	virtual int			mseparatebluenoisematrix(int componentnum);
};
